#!/usr/bin/perl

use strict;
use warnings;

use Readonly;
use SDL;
use SDLx::App;
use SDL::Mouse;
use SDL::Video;
use SDL::Events;
use SDL::Event;
use OpenGL qw(:all);

use JGoff::App::Rubik;

Readonly my $TITLE  => 'OpenGL App';
Readonly my $WIDTH  => 640;
Readonly my $HEIGHT => 400;

Readonly my $X => 0;
Readonly my $Y => 1;

my $sdl_app = SDLx::App->new(
  title	 => $TITLE,
  width	 => $WIDTH,
  height => $HEIGHT,
  gl     => 1
);
my $sdl_event = SDL::Event->new;

#   /
#  /
# z
# x -->
# y
# |
# V
#
#   4 -- 5
#  /    /|
# 0 -- 1 |
# | 6 -| 7
# |/   |/
# 2 -- 3

my $rubik = JGoff::App::Rubik->new(
  corners => [
    [ -1, -1, +1 ],
    [ +1, -1, +1 ],
    [ -1, +1, +1 ],
    [ +1, +1, +1 ],
    [ -1, -1, -1 ],
    [ +1, -1, -1 ],
    [ -1, +1, -1 ],
    [ +1, +1, -1 ],
  ],
  spacing => 0.1,
);

my ( $vertices, $cubes ) = $rubik->generate;

my @indices = (
  [ 4, 5, 6, 7 ],
  [ 1, 2, 6, 5 ],
  [ 0, 1, 5, 4 ],
  [ 0, 3, 2, 1 ],
  [ 0, 4, 7, 3 ],
  [ 2, 3, 7, 6 ],
);
my @vertices = (
  [ -1, -1, -1 ],
  [  1, -1, -1 ],
  [  1,  1, -1 ],
  [ -1,  1, -1 ],
  [ -1, -1,  1 ],
  [  1, -1,  1 ],
  [  1,  1,  1 ],
  [ -1,  1,  1 ]
);

$|++;

#                                                     /
#                                                    /
# Given 8 vertices laid out in this order ( x --> y z
#                                                 |
#                                                 v
#    4 -- 5
# 0 -- 1  |
# |  | |  |
# |  6 -- 7
# 2 -- 3
#
# interpolate between them to get the faces for 27 cubes.
#

# 0 -- 1
# |    |
# |    |
# 2 -- 3

my ( $facets, $flattened ) = $rubik->facets( [
  [ 0.0, 0.0 ], [ 3.1, 0.0 ],
  [ 0.0, 0.0 ], [ 2.2, -0.9 ],
] );

my ( $cubies, $flattened_faces ) = $rubik->cubies( [
#  [ 0.0, 0.0, 0.0 ], [ 3.1, 0.0, 0.0 ],
#  [ 0.0, 0.0, 0.0 ], [ 2.2, -0.9, 0.0 ],
#  [ 0.0, 0.0, 1.0 ], [ 3.1, 0.0, 1.0 ],
#  [ 0.0, 0.0, 1.0 ], [ 2.2, -0.9, 1.0 ],

  [ 0, 0, 0 ], [ 10, 0, 0 ],
  [ 0, 10, 0 ], [ 10, 10, 0 ],
  [ 0, 0, 10 ], [ 10, 0, 10 ],
  [ 0, 10, 10 ], [ 10, 10, 10 ],
] );

#use YAML; die Dump($flattened_faces);

sub draw_facets {
  glBegin(GL_QUADS);
    for my $facet ( @$facets ) {
      for my $idx ( @{ $facet } ) {
        glVertex3d( $flattened->[$idx][$X], $flattened->[$idx][$Y], 0 );
      }
    }
  glEnd;
}

sub draw_cubies {
  glBegin(GL_QUADS);
    for my $cubie ( @{ $cubies } ) {
      for my $facet ( @{ $cubie } ) {
        for my $idx ( @{ $facet } ) {
#warn $idx;
          glVertex3d( @{ $flattened_faces->[ $idx ] } );
        }
      }
    }
  glEnd;
}

#                               180 -- 181    182 -- 183    184 -- 185
#                                                                  191
#                        144 -- 145    146 -- 147    148 -- 149    197
#                                                           155    203
#                 108 -- 109    110 -- 111    112 -- 113    161    209
#                                                    119    167    215
#          72  -- 73     74 --  75     76 --  77     123    173
#                                             83     131    179
#     36 -- 37    38 -- 39 -- 40 -- 41        89     137
#                                   47        95     143
# 00 -- 01    02 -- 03    04 -- 05  53        101
# 06 -- 07    08 -- 09    10 -- 11  59        107
# 12 -- 13    14 -- 15    16 -- 17    
# 18 -- 19    20 -- 21    22 -- 23  65
#                                  / |
# 24 -- 25    26 -- 27    28 -- 29  71
#  |     |     |     |     |     | /
# 30 -- 31    32 -- 33    34 -- 35

#   1
#  /|
# 0 |
# | |
# 2 |
#  \|
#   3

sub draw_pane {
  my @corners = (
    [ 0, 1, 0 ],
    [ 1, 0, 0 ],
    [ 0, 2, 0 ],
    [ 1, 3, 0 ],
  );
  my @vertex = ( 0, 1, 3, 2 );

  glBegin(GL_QUADS);
    for my $idx ( @vertex ) {
      glVertex3d( @{ $corners[ $idx ] } );
    }
  glEnd();
}

# {{{ draw_cube

sub draw_cube {
  glBegin(GL_QUADS);

  for my $indices ( @indices ) {
    for my $index ( @{ $indices } ) {
      glVertex3d( @{ $vertices[ $index ] } );
    }
  }

  glEnd;
}

# }}}

# {{{ draw_scene

sub draw_scene {
#  for my $x ( -1 .. 1 ) {
#    for my $y ( -1 .. 1 ) {
#      for my $z ( -1 .. 1 ) {
        glPushMatrix;
#        glTranslatef( $x * 3, $y * 3, $z * 3 );
        glColor3d( 1, 0, 0 );
        #draw_cube;
        #draw_pane;
        #draw_facets;
        draw_cubies;
        glPopMatrix;
#      }
#    }
#  }
}

# }}}

# {{{ handle_polls

sub handle_polls {
  SDL::Events::pump_events;

  while ( SDL::Events::poll_event( $sdl_event ) ) {
    my $type = $sdl_event->type;
    my $key = ( $type == 2 or $type == 3 ) ? $sdl_event->key_sym : '';

    if ( $type == 4 ) {
#      printf "You moved the mouse! x=%s y=%s xrel=%s yrel=%s\n",
#             $sdl_event->motion_x,
#             $sdl_event->motion_y,
#             $sdl_event->motion_xrel,
#             $sdl_event->motion_yrel
    }
#    elsif ( $type == 2 ) { print "You are pressing $key\n" }
#    elsif ( $type == 3 ) { print "You released $key\n" }
    elsif ( $type == 12 ) { exit }
    else { print "TYPE $type UNKNOWN!\n" }

    if ( $type == 2 ) {
      exit if $key eq "q" or $key eq "escape";
    }
  }
}

# }}}

glEnable( GL_DEPTH_TEST );
glMatrixMode( GL_PROJECTION );
glLoadIdentity;
gluPerspective( 60, $WIDTH / $HEIGHT, 1, 1000 );
glTranslatef( 0, 0, -20 );

while ( 1 ) {
  handle_polls;
  glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
  glRotatef( .1, 1, 1, 1 );
  draw_scene;
  $sdl_app->sync;
}
